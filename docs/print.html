<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build your own CouchDB</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="01-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="02-persistent-storage.html"><strong aria-hidden="true">2.</strong> Persistent storage</a></li><li><a href="03-abstract-database-access.html"><strong aria-hidden="true">3.</strong> Abstract database access</a></li><li><a href="04-create-database-only-when-missing.html"><strong aria-hidden="true">4.</strong> Create database only when missing</a></li><li><a href="05-testing-introduction.html"><strong aria-hidden="true">5.</strong> Testing introduction</a></li><li><a href="06-tests-that-are-expected-to-fail.html"><strong aria-hidden="true">6.</strong> Tests that are expected to fail</a></li><li><a href="07-getting-all-revisions-of-document.html"><strong aria-hidden="true">7.</strong> Gettting all revisions of document</a></li><li><a href="08-benchmarking.html"><strong aria-hidden="true">8.</strong> Bencmarking</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Build your own CouchDB</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#build-your-own-couchdb" id="build-your-own-couchdb"><h1>Build your own CouchDB</h1></a>
<p>Hi! I'm Arve and this is my adventure into building my own modern CouchDB with Rust.</p>
<a class="header" href="#what-is-couchdb" id="what-is-couchdb"><h2>What is CouchDB?</h2></a>
<p><a href="https://couchdb.apache.org/">CouchDB</a> is an key-value database written in Erlang, initially released in 2005. It has a simple replication protocol over HTTP, using revisions to ensure eventual consistency.</p>
<a class="header" href="#why-im-building-my-own" id="why-im-building-my-own"><h2>Why I'm building my own?</h2></a>
<p>CouchDB leaves me longing for better interoperability with modern browsers. Specifically I want &quot;real time&quot; replication to IndexedDB, which is unpleasant with regular CouchDB. The unpleasantness is mainly due to the revision mechanism, which is fairly Erlang specific. Revisions hashes are calculated using Erlang data structures and md5, both which are not native in browsers. Of course it is possible to achieve the revision calculation with some extra libraries. Still, I think it will be a fun challenge to implement a modern CouchDB variant after the <em>build your own x</em>-pattern.</p>
<p>With no further ado, let’s start the journey and look at the objectives.</p>
<a class="header" href="#objectives" id="objectives"><h2>Objectives</h2></a>
<p>Decisions made should reflect the main goals, they are:</p>
<a class="header" href="#goals" id="goals"><h3>Goals</h3></a>
<ul>
<li>Easy interoperability with other programming environments.</li>
<li>Efficient and simple syncing.</li>
<li>Use browser native protocols / APIs.</li>
<li>Availability and Partition tolerance of <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP</a>.</li>
</ul>
<p>To help finishing the project, some non-goals will restrict scope and complexity:</p>
<a class="header" href="#non-goals" id="non-goals"><h3>Non goals</h3></a>
<ul>
<li>Compatibility with CouchDB.</li>
<li>Writing low level code.</li>
<li>Exstensive server side logic, like index lookup and <a href="https://docs.couchdb.org/en/master/ddocs/index.html">design documents</a>.</li>
<li>Consistency of CAP.</li>
</ul>
<a class="header" href="#persistent-storage" id="persistent-storage"><h1>Persistent storage</h1></a>
<p>Lets start with designing the disk storage format. The non-goal <em>Writing low level code</em> stears off designing a file format and using direct file access. A good alternative is <a href="https://sqlite.org/">SQLite</a>. Lets set it up first.</p>
<a class="header" href="#bootstrapping-the-project" id="bootstrapping-the-project"><h2>Bootstrapping the project</h2></a>
<p>I'll call the project <em>sakkosekk</em>, which is Norwegian for bean bag chair.</p>
<p>Bootstrapping with <a href="https://doc.rust-lang.org/cargo/">Cargo</a>:</p>
<pre><code class="language-sh">~/g/build-your-own-couchdb $ cargo init sakkosekk
     Created binary (application) package
~/g/build-your-own-couchdb $ cd sakkosekk/
~/g/b/sakkosekk $ cargo run
   Compiling sakkosekk v0.1.0 (/Users/arve/git/build-your-own-couchdb/sakkosekk)
    Finished dev [unoptimized + debuginfo] target(s) in 10.24s
     Running `target/debug/sakkosekk`
Hello, world!
</code></pre>
<a class="header" href="#adding-sqlite" id="adding-sqlite"><h2>Adding SQLite</h2></a>
<p>Bindings for SQLite is available through the <a href="https://github.com/jgallagher/rusqlite/">rusqlite</a> crate:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ echo '[dependencies]' &gt;&gt; Cargo.toml
~/g/b/sakkosekk $ echo 'rusqlite = { version = &quot;0.20&quot;, features = [&quot;bundled&quot;] }' &gt;&gt; Cargo.toml
</code></pre>
<p>The <em>bundled</em> feature is enabled for hassle free sqlite3 linking.</p>
<a class="header" href="#database-schema" id="database-schema"><h2>Database schema</h2></a>
<p>Documents in the database will have the columns:</p>
<ul>
<li>indentifier,</li>
<li>revision,</li>
<li>hash and</li>
<li>document data.</li>
</ul>
<p>Open database:</p>
<pre><pre class="playpen"><code class="language-rust">use rusqlite::{named_params, Connection};

fn main() {
    let db = Connection::open(&quot;database.sqlite&quot;).expect(&quot;Unable to open 'database.sqlite'.&quot;);
</code></pre></pre>
<p>Creating table:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    db.execute_batch(
        &quot;create table documents (
            id text primary key not null,
            revision integer not null,
            hash blob not null,
            data text not null
        )&quot;,
    )
    .expect(&quot;Unable to create documents table.&quot;);
#}</code></pre></pre>
<p>Inserting document:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    db.execute_named(
        &quot;insert into documents (id, revision, hash, data)
        values (:id, :revision, :hash, :data)&quot;,
        named_params!(
            &quot;:id&quot;: &quot;asdf&quot;,
            &quot;:revision&quot;: 0,
            &quot;:hash&quot;: vec![0u8],
            &quot;:data&quot;: r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#
        ),
    )
    .expect(&quot;Unable to insert document.&quot;);
#}</code></pre></pre>
<p>Reading document by the identifier:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let data: String = db
        .query_row_named(
            &quot;select data from documents where id=:id&quot;,
            named_params!(&quot;:id&quot;: &quot;asdf&quot;),
            |row| row.get(0),
        )
        .expect(&quot;Unable to get document with id 'asdf'&quot;);

    println!(&quot;data: {}&quot;, data);
}
#}</code></pre></pre>
<p>Result:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/sakkosekk`
data: { &quot;a&quot;: 1, &quot;b&quot;: 123 }
</code></pre>
<p>Next up: Abstractions around creating the database schema, inserting documents and reading documents.</p>
<a class="header" href="#abstract-database-access" id="abstract-database-access"><h1>Abstract database access</h1></a>
<p>In the previous chapter, we inserted and read documents directly with rusqlite. To gain cleaner code, lets abstract it away with a type and some methods.</p>
<a class="header" href="#data-fields" id="data-fields"><h2>Data fields</h2></a>
<p>Rust provides <em>structs</em> to gather data fields:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Document {
    id: String,
    revision: i64,
    hash: Vec&lt;u8&gt;,
    data: String,
}
#}</code></pre></pre>
<a class="header" href="#document-methods" id="document-methods"><h2>Document methods</h2></a>
<p>Methods are implementet on the struct, which is more or less a copy of the previous <code>main</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Document {
    fn create_table(db: &amp;Connection) -&gt; Result&lt;(), SqliteError&gt; {
        db.execute_batch(
            &quot;create table documents (
            id text primary key not null,
            revision integer not null,
            hash blob not null,
            data text not null
        )&quot;,
        )
    }

    fn insert(&amp;self, db: &amp;Connection) -&gt; Result&lt;usize, SqliteError&gt; {
        db.execute_named(
            &quot;insert into documents (id, revision, hash, data)
        values (:id, :revision, :hash, :data)&quot;,
            named_params!(
                &quot;:id&quot;: &amp;self.id,
                &quot;:revision&quot;: self.revision,
                &quot;:hash&quot;: &amp;self.hash,
                &quot;:data&quot;: &amp;self.data,
            ),
        )
    }

    fn get_by_id(id: &amp;str, db: &amp;Connection) -&gt; Result&lt;Self, SqliteError&gt; {
        db.query_row_named(
            &quot;select id, revision, hash, data from documents where id=:id&quot;,
            named_params!(&quot;:id&quot;: id),
            Document::row_mapper,
        )
    }

    fn row_mapper(row: &amp;Row) -&gt; Result&lt;Self, SqliteError&gt; {
        Ok(Self {
            id: row.get(0)?,
            revision: row.get(1)?,
            hash: row.get(2)?,
            data: row.get(3)?,
        })
    }
}
#}</code></pre></pre>
<p><code>Row</code> and <code>SqliteError</code> are imported from rusqlite:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rusqlite::{named_params, Connection, Error as SqliteError, Row};
#}</code></pre></pre>
<a class="header" href="#using-the-document-data-type" id="using-the-document-data-type"><h2>Using the <code>Document</code> data type</h2></a>
<p>The main function now reduces to:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let db = Connection::open(&quot;database.sqlite&quot;).expect(&quot;Unable to open 'database.sqlite'.&quot;);

    Document::create_table(&amp;db).expect(&quot;Unable to create documents table.&quot;);

    let document = Document {
        id: String::from(&quot;asdf&quot;),
        revision: 0,
        hash: vec![0u8],
        data: String::from(r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#),
    };

    document.insert(&amp;db).expect(&quot;Unable to insert document.&quot;);

    let document_from_db = Document::get_by_id(&quot;asdf&quot;, &amp;db)
        .expect(&quot;Unable to get document with id 'asdf'&quot;);

    println!(&quot;data: {}&quot;, &amp;document_from_db.data);
}
</code></pre></pre>
<a class="header" href="#thread-main-panicked" id="thread-main-panicked"><h2>thread 'main' panicked</h2></a>
<p>Running the code gives:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/sakkosekk`
thread 'main' panicked at 'Unable to create documents table.: SqliteFailure(Error { code: Unknown, extended_code: 1 }, Some(&quot;table documents already exists&quot;))', src/libcore/result.rs:999:5
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
~/g/b/sakkosekk [101] $
</code></pre>
<p>The code assumes an empty database and fails with exit code 101.</p>
<p>Removing the database before running works:</p>
<pre><code class="language-sh">~/g/b/sakkosekk (master|✚2) [101] $ rm database.sqlite &amp;&amp; cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/sakkosekk`
data: { &quot;a&quot;: 1, &quot;b&quot;: 123 }
</code></pre>
<p>Next up: Fixing this error.</p>
<a class="header" href="#create-database-only-when-missing" id="create-database-only-when-missing"><h1>Create database only when missing</h1></a>
<p>Currently, our application crashes when the database exists. Helper function that checks for existence and only create tables upon an empty database:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn get_db_create_if_missing(filename: &amp;str) -&gt; Connection {
    // Connection::open will create file if missing, check before.
    let exists = Path::new(filename).exists();

    let db = Connection::open(filename)
        .unwrap_or_else(|_| panic!(format!(&quot;Unable to open database file {}&quot;, filename)));

    if !exists {
        // create schema
        Document::create_table(&amp;db).expect(&quot;Unable to create documents table.&quot;);
    }

    db
}
#}</code></pre></pre>
<p><code>Path</code> import:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::path::Path;
#}</code></pre></pre>
<p><code>main</code> function simplifies to:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let db = get_db_create_if_missing(&quot;database.sqlite&quot;);

    let document = Document {
        id: String::from(&quot;asdf&quot;),
        revision: 0,
        hash: vec![0u8],
        data: String::from(r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#),
    };

    document.insert(&amp;db).expect(&quot;Unable to insert document.&quot;);

    let document_from_db = Document::get_by_id(&quot;asdf&quot;, &amp;db)
        .expect(&quot;Unable to get document with id 'asdf'&quot;);

    println!(&quot;data: {}&quot;, &amp;document_from_db.data);
}
</code></pre></pre>
<p>The application still crashes, but with a different error:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/sakkosekk`
thread 'main' panicked at 'Unable to insert document.: SqliteFailure(Error { code: ConstraintViolation, extended_code: 1555 }, Some(&quot;UNIQUE constraint failed: documents.id&quot;))', src/libcore/result.rs:999:5
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Next up: Refactor the main function into tests.</p>
<a class="header" href="#testing-introduction" id="testing-introduction"><h1>Testing introduction</h1></a>
<p>Cargo provides a test runner, <code>cargo test</code> which runs functions annotated with <code>#[test]</code>. Lets create a test which checks that <code>get_db_create_if_missing</code> does not crash if called twice, <em>src/tests.rs</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod database {
    use crate::*;
    use std::fs::remove_file;

    #[test]
    fn creating_database_twice_should_not_fail() {
        get_db_create_if_missing(&quot;test.sqlite&quot;);
        get_db_create_if_missing(&quot;test.sqlite&quot;);
        remove_file(&quot;test.sqlite&quot;).unwrap();
    }
}
#}</code></pre></pre>
<p>Here, <code>#[cfg(test)]</code> tells Rust that the module should only compile when compiling tests. <code>mod database</code> is a grouping for the database tests.</p>
<p>Running the test:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ cargo test
   Compiling sakkosekk v0.1.0 (/Users/arve/git/build-your-own-couchdb/sakkosekk)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/sakkosekk-5d572632b2e9bfcc

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><em>Running 0 tests</em>? We need to add <code>mod tests</code> to <em>src/main.rs</em>, such that the <code>tests</code> module is found:</p>
<pre><pre class="playpen"><code class="language-rust">use rusqlite::{named_params, Connection, Error as SqliteError, Row};
use std::path::Path;

mod tests;

fn main() {
    let db = get_db_create_if_missing(&quot;database.sqlite&quot;);
...
</code></pre></pre>
<p>Really run the test:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ cargo test
   Compiling sakkosekk v0.1.0 (/Users/arve/git/build-your-own-couchdb/sakkosekk)
    Finished dev [unoptimized + debuginfo] target(s) in 1.85s
     Running target/debug/deps/sakkosekk-5d572632b2e9bfcc

running 1 test
test tests::database::creating_database_twice_should_not_fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="#insertion" id="insertion"><h2>Insertion</h2></a>
<p>Naivly adding an insertion test:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod database {
    use crate::*;
    use std::fs::remove_file;

    const TEST_DB_FILENAME: &amp;str = &quot;test.sqlite&quot;;

    #[test]
    fn creating_database_twice_should_not_fail() {
        get_db_create_if_missing(TEST_DB_FILENAME);
        get_db_create_if_missing(TEST_DB_FILENAME);
        clean_up();
    }

    #[test]
    fn insertion() {
        let db = get_db_create_if_missing(TEST_DB_FILENAME);

        let document = Document {
            id: String::from(&quot;asdf&quot;),
            revision: 0,
            hash: vec![0u8],
            data: String::from(r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#),
        };

        document.insert(&amp;db).expect(&quot;Unable to insert document.&quot;);

        clean_up();
    }

    fn clean_up() {
        remove_file(TEST_DB_FILENAME).unwrap();
    }
}
#}</code></pre></pre>
<p>This will fail:</p>
<pre><code class="language-sh">~/g/b/sakkosekk (master|✚2…) $ cargo test
   Compiling sakkosekk v0.1.0 (/Users/arve/git/build-your-own-couchdb/sakkosekk)
    Finished dev [unoptimized + debuginfo] target(s) in 1.14s
     Running target/debug/deps/sakkosekk-5d572632b2e9bfcc

running 2 tests
test tests::database::insertion ... ok
test tests::database::creating_database_twice_should_not_fail ... FAILED

failures:

---- tests::database::creating_database_twice_should_not_fail stdout ----
thread 'tests::database::creating_database_twice_should_not_fail' panicked at 'Unable to create documents table.: SqliteFailure(Error { code: Unknown, extended_code: 1 }, Some(&quot;table documents already exists&quot;))', src/libcore/result.rs:999:5
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::database::creating_database_twice_should_not_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--bin sakkosekk'
</code></pre>
<p>The test <code>creating_database_twice_should_not_fail</code> fails, as tests runs in parallel. We'll use a helper function <code>with</code> that:</p>
<ul>
<li>takes a filename and a test function,</li>
<li>creates a database connection,</li>
<li>runs the given test function with the created database connection,</li>
<li>and removes the database file.</li>
</ul>
<p>Using the function should look like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
with(&quot;filename.sqlite&quot;, |db| {
    // use db connection
});
// with will clean up / remove the database
#}</code></pre></pre>
<p><code>with</code> implementation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn with&lt;F&gt;(filename: &amp;str, test: F)
    where
        F: Fn(Connection) -&gt; (),
    {
        let db = get_db_create_if_missing(filename);
        test(db);
        remove_file(filename).unwrap();
    }
#}</code></pre></pre>
<p><strong>Note:</strong> An alternative <code>with</code> is to implement <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> for our own <code>Connection</code>-type.</p>
<p>The tests rewritten to use <code>with</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn creating_database_twice_should_not_fail() {
        with(&quot;creating_twice.sqlite&quot;, |_| {
            get_db_create_if_missing(&quot;creating_twice.sqlite&quot;);
        });
    }

    #[test]
    fn insertion() {
        with(&quot;insertion.sqlite&quot;, |db| {
            let document = Document {
                id: String::from(&quot;asdf&quot;),
                revision: 0,
                hash: vec![0u8],
                data: String::from(r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#),
            };

            document.insert(&amp;db).expect(&quot;Unable to insert document.&quot;);
        });
    }
#}</code></pre></pre>
<p>Note that the tests use different filenames for the database.</p>
<p>Running the tests does not fail:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ cargo test
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running target/debug/deps/sakkosekk-5d572632b2e9bfcc

running 2 tests
test tests::database::creating_database_twice_should_not_fail ... ok
test tests::database::insertion ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Next up: Tests that are expected to fail, like inserting a document with the same identifier twice.</p>
<a class="header" href="#tests-that-are-expected-to-fail" id="tests-that-are-expected-to-fail"><h1>Tests that are expected to fail</h1></a>
<p>We could make our tests panic and annotate tests with <code>#[should_panic]</code>, but as our methods return <code>Result</code>, the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err"><code>is_err</code></a> method tells us that the correct method call failed.</p>
<a class="header" href="#insertion-failure" id="insertion-failure"><h2>Insertion failure</h2></a>
<p>A double insertion of the same document should fail:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn double_insertion_should_fail() {
        with(&quot;double_insertion.sqlite&quot;, |db| {
            let document = Document {
                id: String::from(&quot;asdf&quot;),
                revision: 0,
                hash: vec![0u8],
                data: String::from(r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#),
            };

            document.insert(&amp;db).expect(&quot;Unable to insert document.&quot;);
            let second_insert_result = document.insert(&amp;db);
            assert!(second_insert_result.is_err());
        });
    }
#}</code></pre></pre>
<p>Actually, this test is wrong. In CouchDB a document can have many revisions, making <code>id</code>, <code>revision</code> and <code>hash</code> unique.</p>
<a class="header" href="#insertion-failure-only-when-same-revision" id="insertion-failure-only-when-same-revision"><h2>Insertion failure only when same revision</h2></a>
<p>This fails as expected:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn insert_multiple_revisions() {
        with(&quot;insert_multiple_revisions.sqlite&quot;, |db| {
            let insert = |revision: i64| {
                let document = Document {
                    id: String::from(&quot;asdf&quot;),
                    revision: revision,
                    hash: vec![0u8],
                    data: String::from(r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#),
                };

                document.insert(&amp;db).expect(&quot;Unable to insert document.&quot;);
            };

            insert(0);
            insert(1);
        });
    }
#}</code></pre></pre>
<p>We'll fix it by removing <code>primary key</code> from <code>id</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn create_table(db: &amp;Connection) -&gt; Result&lt;(), SqliteError&gt; {
        db.execute_batch(
            &quot;create table documents (
            id text not null,
            revision integer not null,
            hash blob not null,
            data text not null
        )&quot;,
        )
    }
#}</code></pre></pre>
<p>Running tests again does not seem to have fixed <code>insert_multiple_revisions</code>, also <code>double_insertion_should_fail</code> fails now:</p>
<pre><code>running 4 tests
test tests::database::creating_database_twice_should_not_fail ... ok
test tests::database::insert_multiple_revisions ... FAILED
test tests::database::double_insertion_should_fail ... FAILED
test tests::database::insertion ... ok
</code></pre>
<p>As the tests paniced, <code>remove_file</code> in <code>with</code> never runs. Fix it by removing file before opening:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn with&lt;F&gt;(filename: &amp;str, test: F)
    where
        F: Fn(Connection) -&gt; (),
    {
        remove_file(filename).unwrap_or(());
        let db = get_db_create_if_missing(filename);
        test(db);
        remove_file(filename).unwrap();
    }
#}</code></pre></pre>
<p><code>unwrap_or(())</code> ignores any errors in deleting the file.</p>
<p>Running tests again:</p>
<pre><code>running 4 tests
test tests::database::creating_database_twice_should_not_fail ... ok
test tests::database::double_insertion_should_fail ... FAILED
test tests::database::insert_multiple_revisions ... ok
test tests::database::insertion ... ok
</code></pre>
<p><code>insert_multiple_revisions</code> is OK, but <code>double_insertion_should_fail</code> is still failing. It fails as <code>primary key</code> constraint was removed.</p>
<p>Adding a unique constraint should fix id:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn create_table(db: &amp;Connection) -&gt; Result&lt;(), SqliteError&gt; {
        db.execute_batch(
            &quot;create table documents (
                id text not null,
                revision integer not null,
                hash blob not null,
                data text not null,
                unique(id, revision, hash)
            );
            &quot;,
        )
    }
#}</code></pre></pre>
<a class="header" href="#get-non-existent-document" id="get-non-existent-document"><h2>Get non-existent document</h2></a>
<p>Getting a missing document should fail:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn get_by_missing_id_should_fail() {
        with(&quot;get_by_id_missing.sqlite&quot;, |db| {
            let result = Document::get_by_id(&quot;asdf&quot;, &amp;db);
            assert!(result.is_err());
        });
    }
#}</code></pre></pre>
<p>Make sure all tests pass:</p>
<pre><code>running 5 tests
test tests::database::get_by_missing_id_should_fail ... ok
test tests::database::creating_database_twice_should_not_fail ... ok
test tests::database::double_insertion_should_fail ... ok
test tests::database::insert_multiple_revisions ... ok
test tests::database::insertion ... ok
</code></pre>
<p>Next up: Get by id should return all revisions of document.</p>
<a class="header" href="#getting-all-revisions-of-document" id="getting-all-revisions-of-document"><h1>Getting all revisions of document</h1></a>
<p>In <a href="./02-persistent-storage.html">Persistent storage</a> we naively used <code>id</code> to look up a single document, but a document can have multiple revisions. In other words, <code>Document::get_by_id</code> should return a list of documents.</p>
<a class="header" href="#refactoring-tests" id="refactoring-tests"><h2>Refactoring tests</h2></a>
<p>First, the tests are repeating themself. Currently the tests <code>insertion</code>, <code>double_insertion_should_fail</code> and <code>insert_multiple_revisions</code> are all repeating declaration of a <code>document</code>.</p>
<p>Move document declaration into a function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn get_document(revision: i64) -&gt; Document {
        Document {
            id: String::from(&quot;asdf&quot;),
            revision: revision,
            hash: vec![0u8],
            data: String::from(r#&quot;{ &quot;a&quot;: 1, &quot;b&quot;: 123 }&quot;#),
        }
    }
#}</code></pre></pre>
<p>Tests refactored to use <code>get_document</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn insertion() {
        with(&quot;insertion.sqlite&quot;, |db| {
            get_document(0).insert(&amp;db).expect(&quot;Unable to insert document.&quot;);
        });
    }

    #[test]
    fn double_insertion_should_fail() {
        with(&quot;double_insertion.sqlite&quot;, |db| {
            get_document(0).insert(&amp;db).expect(&quot;Unable to insert document.&quot;);
            let second_insert_result = get_document(0).insert(&amp;db);
            assert!(second_insert_result.is_err());
        });
    }

    #[test]
    fn insert_multiple_revisions() {
        with(&quot;insert_multiple_revisions.sqlite&quot;, |db| {
            get_document(0).insert(&amp;db).expect(&quot;Unable to insert document.&quot;);
            get_document(1).insert(&amp;db).expect(&quot;Unable to insert document.&quot;);
        });
    }

#}</code></pre></pre>
<a class="header" href="#get-document-by-identifier-test" id="get-document-by-identifier-test"><h2>Get document by identifier test</h2></a>
<p>Now the test for <code>Document::get_by_id</code>, using <code>get_document</code>. The test should check that <code>Document::get_by_id</code> returns all documents:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn get_by_id() {
        with(&quot;get_by_id.sqlite&quot;, |db| {
            get_document(0)
                .insert(&amp;db)
                .expect(&quot;Unable to insert document.&quot;);
            get_document(1)
                .insert(&amp;db)
                .expect(&quot;Unable to insert document.&quot;);

            let documents_from_db = Document::get_by_id(&quot;asdf&quot;, &amp;db);

            assert!(documents_from_db == Ok(vec![get_document(0), get_document(1)]));
        });
    }
#}</code></pre></pre>
<p>This fails compiling for two reasons. Lets takle number one first; <code>Document</code> does not implement the method <code>eq</code> from the [<code>PartialEq</code> trait].</p>
<p>Error message:</p>
<pre><code>error[E0369]: binary operation `==` cannot be applied to type `std::result::Result&lt;Document, rusqlite::error::Error&gt;`
  --&gt; src/tests.rs:53:39
   |
53 |             assert!(documents_from_db == Ok([get_document(0), get_document(1)]));
   |                     ----------------- ^^ -------------------------------------- std::result::Result&lt;[Document; 2], _&gt;
   |                     |
   |                     std::result::Result&lt;Document, rusqlite::error::Error&gt;
   |
   = note: an implementation of `std::cmp::PartialEq` might be missing for `std::result::Result&lt;Document, rusqlite::error::Error&gt;`
</code></pre>
<p>As all fields in <code>Document</code> implements <code>PartialEq</code>, we can derive <code>PartialEq</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq)]
struct Document {
    id: String,
    revision: i64,
    hash: Vec&lt;u8&gt;,
    data: String,
}
#}</code></pre></pre>
<p>Now, <code>cargo tests</code> yields the other error:</p>
<pre><code>error[E0308]: mismatched types
  --&gt; src/tests.rs:53:45
   |
53 |             assert!(documents_from_db == Ok([get_document(0), get_document(1)]));
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Document`, found array of 2 elements
   |
   = note: expected type `Document`
              found type `[Document; 2]`
</code></pre>
<p><code>query_row_named</code> only returns a single row. <a href="https://docs.rs/rusqlite/0.20.0/rusqlite/struct.Statement.html"><code>Statement</code></a> provides <a href="https://docs.rs/rusqlite/0.20.0/rusqlite/struct.Statement.html#method.query_map_named"><code>query_map_named</code></a> that gives more then one row. [<code>Connection::prepare</code>] yields a <code>Statement</code>.</p>
<p><code>Document::get_by_id</code> rewritten to use a <code>Statement</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn get_by_id(id: &amp;str, db: &amp;Connection) -&gt; Result&lt;Vec&lt;Self&gt;, SqliteError&gt; {
        db.prepare(&quot;select id, revision, hash, data from documents where id=:id&quot;)?
            .query_map_named(named_params!(&quot;:id&quot;: id), Document::row_mapper)?
            .collect()
    }
#}</code></pre></pre>
<p><code>cargo tests</code> gives a compilation error:</p>
<pre><code>error[E0609]: no field `data` on type `std::vec::Vec&lt;Document&gt;`
  --&gt; src/main.rs:21:44
   |
21 |     println!(&quot;data: {}&quot;, &amp;document_from_db.data);
   |                                            ^^^^ unknown field
</code></pre>
<p>As <code>get_by_id</code> have a new return signature and <code>Vec</code> does not have a <code>data</code>-field. Fix it by removing the line.</p>
<p>Running tests shows that <code>get_by_missing_id</code> is failing:</p>
<pre><code>running 5 tests
test tests::database::creating_database_twice_should_not_fail ... ok
test tests::database::get_by_missing_id_should_fail ... FAILED
test tests::database::double_insertion_should_fail ... ok
test tests::database::insert_multiple_revisions ... ok
test tests::database::insertion ... ok
</code></pre>
<p>Fix the test by having it expect an empty vector:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[test]
    fn get_by_missing_id_should_give_no_results() {
        with(&quot;get_by_id_missing.sqlite&quot;, |db| {
            let documents = Document::get_by_id(&quot;asdf&quot;, &amp;db).expect(&quot;Unable to get documents.&quot;);
            assert!(documents.is_empty());
        });
    }
#}</code></pre></pre>
<a class="header" href="#understanding-get_by_id" id="understanding-get_by_id"><h3>Understanding <code>get_by_id</code></h3></a>
<p>A lot happens in <code>get_by_id</code>. Looking at the types can help in understanding the code.</p>
<ol start="0">
<li><code>Result&lt;T&gt;</code> is here <code>rusqlite::Result&lt;T&gt;</code>, which is equivalent to <code>std::result::Result&lt;T, rusqlite::Error&gt;</code>.</li>
<li><code>prepare</code> returns <code>Result&lt;Statement&gt;</code>.</li>
<li>The question mark <code>?</code> translates to <em>unwrap result or exit early with error</em>.</li>
<li><code>?</code> unwraps <code>Statement</code>.</li>
<li><code>query_map_named</code> returns <code>Result&lt;MappedRows&gt;</code>.</li>
<li><code>?</code> unwraps <code>MappedRows</code>.</li>
<li><code>MappedRows</code> implements <code>IntoIterator</code>, giving us <code>Iterator&lt;Result&lt;Document&gt;&gt;</code>.</li>
<li><code>Iterator::collect</code> uses the return signature, <code>Result&lt;Vec&lt;Self&gt;, SqliteError&gt;</code>, and unwraps <code>Result&lt;Document&gt;</code> one by one, exiting early if one of them fails.</li>
</ol>
<a class="header" href="#note-on-compiler-warnings" id="note-on-compiler-warnings"><h3>Note on compiler warnings</h3></a>
<p>You might have noticed compiler warnings like:</p>
<pre><code>warning: unused variable: `db`
 --&gt; src/main.rs:7:9
  |
7 |     let db = get_db_create_if_missing(&quot;database.sqlite&quot;);
  |         ^^ help: consider prefixing with an underscore: `_db`
  |
  = note: #[warn(unused_variables)] on by default
</code></pre>
<p>We'll fix these warnings later when using the database interface in our actual application.</p>
<p><strong>Next up:</strong> Benchmarking</p>
<a class="header" href="#benchmarking" id="benchmarking"><h1>Benchmarking</h1></a>
<p>As you might have noticed, we did not add an index when removing the primary key. This may affect performance when looking up entries on the <code>id</code> column.</p>
<p>The <a href="https://github.com/bheisler/criterion.rs">criterion</a> crate gives some nice tools for statistics-driven benchmarking.</p>
<a class="header" href="#splitting-into-library-and-binary" id="splitting-into-library-and-binary"><h2>Splitting into library and binary</h2></a>
<p>Criterion has some <a href="https://bheisler.github.io/criterion.rs/book/user_guide/known_limitations.html">known limitations</a>. One limitation is benchmarking a binary crate, which is not possible. To overcome the limitation, we split our project into a library and a binary.</p>
<p>Move <em>main.rs</em> to <em>lib.rs</em>:</p>
<pre><code class="language-sh">mv src/main.rs src/lib.rs
</code></pre>
<p>Remove the <code>main</code>-function and make <code>get_db_create_if_missing</code>, <code>Document</code>, <code>Document</code>-fields and some of the <code>Document</code>-methods public:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rusqlite::{named_params, Connection, Error as SqliteError, Row};
use std::path::Path;

mod tests;

pub fn get_db_create_if_missing(filename: &amp;str) -&gt; Connection {
    ...
}

#[derive(PartialEq)]
pub struct Document {
    pub id: String,
    pub revision: i64,
    pub hash: Vec&lt;u8&gt;,
    pub data: String,
}

impl Document {
    ...

    pub fn insert(&amp;self, db: &amp;Connection) -&gt; Result&lt;usize, SqliteError&gt; {
        ...
    }

    pub fn get_by_id(id: &amp;str, db: &amp;Connection) -&gt; Result&lt;Vec&lt;Self&gt;, SqliteError&gt; {
        ...
    }

    ...
}
#}</code></pre></pre>
<p><code>...</code> is omitted code that have not changed.</p>
<p>Create a new minimal <code>main</code> function in <em>src/bin/sakkosekk.rs</em>:</p>
<pre><pre class="playpen"><code class="language-rust">use sakkosekk::get_db_create_if_missing;

fn main() {
    let db = get_db_create_if_missing(&quot;database.sqlite&quot;);
    dbg!(db);
}
</code></pre></pre>
<p>Check that both <code>cargo run</code> and <code>cargo test</code> works:</p>
<pre><code class="language-sh">~/g/b/sakkosekk $ cargo run
   Compiling sakkosekk v0.1.0 (/Users/arve/git/build-your-own-couchdb/sakkosekk)
    Finished dev [unoptimized + debuginfo] target(s) in 11.00s
     Running `target/debug/sakkosekk`
[src/bin/sakkosekk.rs:5] db = Connection {
    path: Some(
        &quot;database.sqlite&quot;,
    ),
}
~/g/b/sakkosekk $ cargo test
   Compiling sakkosekk v0.1.0 (/Users/arve/git/build-your-own-couchdb/sakkosekk)
    Finished dev [unoptimized + debuginfo] target(s) in 2.38s
     Running target/debug/deps/sakkosekk-c97044fdfdcd0074

running 6 tests
test tests::database::creating_database_twice_should_not_fail ... ok
test tests::database::get_by_missing_id_should_give_no_results ... ok
test tests::database::double_insertion_should_fail ... ok
test tests::database::get_by_id ... ok
test tests::database::insertion ... ok
test tests::database::insert_multiple_revisions ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/sakkosekk-7673159c8931cebe

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests sakkosekk

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="#creating-our-first-benchmark" id="creating-our-first-benchmark"><h2>Creating our first benchmark</h2></a>
<p>Add criterion as a development dependency and define a benchmark in <em>Cargo.toml:</em></p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.2&quot;

[[bench]]
name = &quot;database&quot;
harness = false
</code></pre>
<p><code>name = &quot;database&quot;</code> must match the filename, make the benchmark as the file <em>benches/database.rs</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use criterion::{criterion_group, criterion_main, Criterion};
use sakkosekk::{get_db_create_if_missing, Document};
use rusqlite::{Connection};
use std::fs::remove_file;

criterion_group!(benches, benchmark);
criterion_main!(benches);

fn benchmark(c: &amp;mut Criterion) {
    c.bench_function(&quot;get documents by id&quot;, |b| {
        let db = BenchDatabase::new(&quot;bench_get_documents_by_id.sqlite&quot;);
        let doc = Document::get_by_id(&quot;bench100&quot;, &amp;db.connection).unwrap();
        assert!(doc.len() == 1);

        b.iter(|| Document::get_by_id(&quot;bench100&quot;, &amp;db.connection))
    });
}

struct BenchDatabase {
    filename: &amp;'static str,
    connection: Connection,
}

impl BenchDatabase {
    fn new(filename: &amp;'static str) -&gt; Self {
        remove_file(filename).unwrap_or(());
        let mut connection = get_db_create_if_missing(filename);
        let transaction = connection.transaction().unwrap();

        for i in 0..1000 {
            let document = Document {
                id: format!(&quot;bench{}&quot;, i),
                revision: 0,
                hash: vec![],
                data: format!(r#&quot;{{ &quot;number&quot;: {} }}&quot;#, i)
            };
            document.insert(&amp;transaction).unwrap();
        }

        transaction.commit().unwrap();

        Self { filename, connection }
    }
}
#}</code></pre></pre>
<p><code>c.bench_function</code> takes a setup function. Latest statement in <code>bench_function</code> is <code>b.iter</code>. Criterion will call the function given to <code>b.iter</code> in a tight loop and collect timing statistics.</p>
<p>Run it with <code>cargo bench</code>:</p>
<pre><code>get documents by id     time:   [25.567 us 25.989 us 26.485 us]
</code></pre>
<p>Lets try adding an index on <code>id</code> and see results of benchmark again.</p>
<p>Adding index index on <code>id</code> in <em>lib.rs</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn create_table(db: &amp;Connection) -&gt; Result&lt;(), SqliteError&gt; {
        db.execute_batch(
            &quot;create table documents (
                id text not null,
                revision integer not null,
                hash blob not null,
                data text not null,
                unique(id, revision, hash)
            );
            create index documents_id_idx on documents(id);
            &quot;,
        )
    }
#}</code></pre></pre>
<p>Run <code>cargo bench</code> to review benchmark:</p>
<pre><code>get documents by id     time:   [26.169 us 26.702 us 27.417 us]
                        change: [-0.4154% +2.4533% +5.1353%] (p = 0.10 &gt; 0.05)
                        No change in performance detected.
</code></pre>
<p>No change in performance detected. Lets investigate with the SQLite REPL:</p>
<pre><code class="language-sql">~/g/b/sakkosekk $ sqlite3 bench_get_documents_by_id.sqlite
SQLite version 3.24.0 2018-06-04 14:10:15
Enter &quot;.help&quot; for usage hints.
sqlite&gt; EXPLAIN QUERY PLAN select * from documents where id='bench100';
QUERY PLAN
`--SEARCH TABLE documents USING INDEX documents_id_idx (id=?)
sqlite&gt; drop index documents_id_idx;
sqlite&gt; EXPLAIN QUERY PLAN select * from documents where id='bench100';
QUERY PLAN
`--SEARCH TABLE documents USING INDEX sqlite_autoindex_documents_1 (id=?)
sqlite&gt;
</code></pre>
<p>SQLite actually creates an <em>autoindex</em>, so we see no performance gain when creating the index. A search in the <a href="https://www.sqlite.org/optoverview.html">SQLite query optimizer documentation</a> reveals some details:</p>
<blockquote>
<p>In SQLite version 3.8.0 (2013-08-26) and later, an SQLITE_WARNING_AUTOINDEX message is sent to the error log every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</p>
</blockquote>
<p>Following the recomendation, I'll leave the definition of the index.</p>
<a class="header" href="#enabling-write-ahead-logging-wal" id="enabling-write-ahead-logging-wal"><h2>Enabling write-ahead logging (WAL)</h2></a>
<p>A common performance recommandation for SQLite is <a href="https://www.sqlite.org/wal.html">write-ahead logging</a>.</p>
<p>Add Enabling WAL-mode:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    ...

    if !exists {
        // create schema
        Document::create_table(&amp;db).expect(&quot;Unable to create documents table.&quot;);

        enable_write_ahead_logging(&amp;db);
    }

    db
}

fn enable_write_ahead_logging(db: &amp;Connection) {
    // PRAGMA journal_mode=wal;
    let result: String = db
        .pragma_update_and_check(None, &quot;journal_mode&quot;, &amp;&quot;wal&quot;, |row| row.get(0))
        .unwrap();
    assert!(&quot;wal&quot; == &amp;result);
}
#}</code></pre></pre>
<p>As before, we use <code>cargo bench</code> to assess performance:</p>
<pre><code>get documents by id     time:   [13.426 us 13.583 us 13.759 us]
                        change: [-51.227% -49.928% -48.677%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
</code></pre>
<p>2x speedup! 14 microseconds gives a decent upper limit for fetches, 1s / 14us ≈ 70k fetches per second on this hardware (2013 macbook air with 250 GB SSD). I'm happy with that, so let's continue with adding a HTTP-layer in front of the disk persistence.</p>
<p><strong>Next up:</strong> Adding HTTP.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
